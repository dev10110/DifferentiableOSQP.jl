var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiableOSQP","category":"page"},{"location":"#DifferentiableOSQP","page":"Home","title":"DifferentiableOSQP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DifferentiableOSQP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a thin wrapper of OSQP.jl, but also provides the ability to differentiate through the quadratic progam, based on the equations in OptNet. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package exports 2 commands: solve and solve_and_jac.","category":"page"},{"location":"#Interface-1:-Solve-a-QP","page":"Home","title":"Interface 1: Solve a QP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"   x = solve(P, q, A, u; kwargs...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solves the quadratic program:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n  min_x   quad frac12 x^T P x + q^T x  \n  st    quad A x leq u\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where kwargs are keyword arguments passed into OSQP.setup!","category":"page"},{"location":"","page":"Home","title":"Home","text":"To include equality constraints, for example G x = h, modify A, u matrices as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = [A ; G ; -G]\nu = [u ; h; -h]","category":"page"},{"location":"","page":"Home","title":"Home","text":"This introduces the constraints G x leq h and G x geq h, allowing equalities to be handled. Yes, this is rather inefficient, but the easiest way to solve the problem I think.","category":"page"},{"location":"#Interface-2:-Solve-a-Parameteric-QP","page":"Home","title":"Interface 2: Solve a Parameteric QP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  x = solve(θ, P_fn, q_fn, A_fn, u_fn; kwargs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solves the quadratic program:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n  min_x   quad frac12 x^T P(theta) x + q(theta)^T x  \n  st    quad A(theta) x leq u(theta)\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"i.e., assumes the P_fn, q_fn, A_fn, u_fn are functions of θ. Note, the shape and size of each output must be correct - for example, A_fn(θ) must return a matrix, and q_fn(θ) must return a vector. ","category":"page"},{"location":"#Interface-3:-Jacobians-of-a-QP","page":"Home","title":"Interface 3: Jacobians of a QP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thinking about interface 2, notice that a QP solver is essentially a function","category":"page"},{"location":"","page":"Home","title":"Home","text":"QP  mathbbR^p to mathbbR^n\nx = QP(θ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, the Jacobian of the QP ","category":"page"},{"location":"","page":"Home","title":"Home","text":"J = fracpartial xpartial theta","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we want the jacobian of QP, we can call it as the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x, J = solve_and_jac(θ, P_fn, q_fn, A_fn, u_fn; kwargs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which gives the optimal solution x, and the jacobian J","category":"page"},{"location":"#Interaface-4:-ForwardDiff","page":"Home","title":"Interaface 4: ForwardDiff","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For convenience, we overloaded solve to handle Dual numbers. This means we can directly use ForwardDiff.jacobian, as in the following example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J = ForwardDiff.jacobian(θ -> solve(θ, P_fn, q_fn, A_fn, u_fn), θ0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or more explictly","category":"page"},{"location":"","page":"Home","title":"Home","text":"function parameteric_qp(θ)\n  return solve(θ, P_fn, q_fn, A_fn, u_fn)\nend\n\nJ = ForwardDiff.jacobian(parametric_qp, θ0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiableOSQP]","category":"page"}]
}
